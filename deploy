#!/usr/bin/env bash
# üöÄ MediApp v3.0.0 - Deploy Unificado e Inteligente
# Sistema automatizado com zero-downtime deployment

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Configura√ß√µes
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly APP_NAME="MediApp"
readonly VERSION="3.0.0"
readonly CONFIG_DIR="$SCRIPT_DIR/config"
readonly BACKUP_DIR="$SCRIPT_DIR/backups"
readonly LOG_DIR="/tmp/mediapp-deploy"

# Cores para output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

# Configura√ß√µes por ambiente
declare -A ENV_CONFIG=(
    ["development"]="dev"
    ["staging"]="stg" 
    ["production"]="prod"
)

declare -A ENV_PORTS=(
    ["development"]="3002"
    ["staging"]="3003"
    ["production"]="80"
)

declare -A ENV_REPLICAS=(
    ["development"]="1"
    ["staging"]="2"
    ["production"]="3"
)

# Logging functions
log() {
    local level=$1; shift
    local msg="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case $level in
        "INFO")  echo -e "${GREEN}[INFO]${NC}  [$timestamp] $msg" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC}  [$timestamp] $msg" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} [$timestamp] $msg" ;;
        "DEBUG") echo -e "${BLUE}[DEBUG]${NC} [$timestamp] $msg" ;;
        "SUCCESS") echo -e "${PURPLE}[SUCCESS]${NC} [$timestamp] $msg" ;;
    esac
    
    # Log to file
    mkdir -p "$LOG_DIR"
    echo "[$level] [$timestamp] $msg" >> "$LOG_DIR/deploy-$(date +%Y%m%d).log"
}

# Banner
print_banner() {
    clear
    echo -e "${PURPLE}"
    cat << 'EOF'
üöÄ ========================================================
   __  __          _ _    _                
  |  \/  | ___  __| (_)  / \   _ __  _ __  
  | |\/| |/ _ \/ _` | | / _ \ | '_ \| '_ \ 
  | |  | |  __/ (_| | |/ ___ \| |_) | |_) |
  |_|  |_|\___|\__,_|_/_/   \_\ .__/| .__/ 
                              |_|   |_|    
        Deploy Automatizado v3.0.0
üöÄ ========================================================
EOF
    echo -e "${NC}"
}

# Parse command line arguments
parse_args() {
    local environment="development"
    local strategy="rolling"
    local skip_tests=false
    local skip_backup=false
    local dry_run=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -e|--environment)
                environment="$2"
                shift 2
                ;;
            -s|--strategy)
                strategy="$2"
                shift 2
                ;;
            --skip-tests)
                skip_tests=true
                shift
                ;;
            --skip-backup)
                skip_backup=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log "ERROR" "Argumento desconhecido: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Validar ambiente
    if [[ ! "${ENV_CONFIG[$environment]:-}" ]]; then
        log "ERROR" "Ambiente inv√°lido: $environment"
        log "INFO" "Ambientes dispon√≠veis: ${!ENV_CONFIG[*]}"
        exit 1
    fi
    
    # Export variables
    export DEPLOY_ENVIRONMENT="$environment"
    export DEPLOY_STRATEGY="$strategy"
    export SKIP_TESTS="$skip_tests"
    export SKIP_BACKUP="$skip_backup"
    export DRY_RUN="$dry_run"
}

show_help() {
    echo -e "${CYAN}USO:${NC}"
    echo "  $0 [OPTIONS]"
    echo ""
    echo -e "${CYAN}OPTIONS:${NC}"
    echo "  -e, --environment ENV    Ambiente de deploy (development|staging|production)"
    echo "  -s, --strategy STRATEGY  Estrat√©gia de deploy (rolling|blue-green|recreate)"
    echo "      --skip-tests         Pular execu√ß√£o de testes"
    echo "      --skip-backup        Pular backup do banco"
    echo "      --dry-run           Simular deploy sem executar"
    echo "  -h, --help              Mostrar esta ajuda"
    echo ""
    echo -e "${CYAN}EXEMPLOS:${NC}"
    echo "  $0 -e development                    # Deploy desenvolvimento"
    echo "  $0 -e production -s blue-green       # Deploy produ√ß√£o com blue-green"
    echo "  $0 -e staging --skip-tests          # Deploy staging sem testes"
}

# Pre-flight checks
preflight_checks() {
    log "INFO" "üîç Executando verifica√ß√µes pr√©-deploy..."
    
    local checks_passed=true
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        log "ERROR" "Docker n√£o encontrado"
        checks_passed=false
    else
        log "DEBUG" "‚úÖ Docker: $(docker --version)"
    fi
    
    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log "ERROR" "Docker Compose n√£o encontrado"
        checks_passed=false
    else
        log "DEBUG" "‚úÖ Docker Compose: $(docker-compose --version)"
    fi
    
    # Check Node.js
    if ! command -v node &> /dev/null; then
        log "ERROR" "Node.js n√£o encontrado"
        checks_passed=false
    else
        local node_version=$(node --version)
        log "DEBUG" "‚úÖ Node.js: $node_version"
        
        # Check version
        local required_version="v18"
        if [[ ! "$node_version" == $required_version* ]]; then
            log "WARN" "Node.js $required_version+ recomendado, atual: $node_version"
        fi
    fi
    
    # Check git (for version info)
    if command -v git &> /dev/null; then
        local git_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
        local git_commit=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        log "DEBUG" "‚úÖ Git: branch=$git_branch, commit=$git_commit"
        export GIT_BRANCH="$git_branch"
        export GIT_COMMIT="$git_commit"
    fi
    
    # Check environment config
    local env_file="$CONFIG_DIR/environments/${DEPLOY_ENVIRONMENT}.env"
    if [[ ! -f "$env_file" ]]; then
        log "ERROR" "Arquivo de configura√ß√£o n√£o encontrado: $env_file"
        checks_passed=false
    else
        log "DEBUG" "‚úÖ Configura√ß√£o: $env_file"
    fi
    
    # Check Docker Compose file
    local compose_file="$CONFIG_DIR/docker/docker-compose.${DEPLOY_ENVIRONMENT}.yml"
    if [[ ! -f "$compose_file" ]]; then
        log "ERROR" "Docker Compose n√£o encontrado: $compose_file"
        checks_passed=false
    else
        log "DEBUG" "‚úÖ Docker Compose: $compose_file"
    fi
    
    if [[ "$checks_passed" != true ]]; then
        log "ERROR" "Verifica√ß√µes pr√©-deploy falharam"
        exit 1
    fi
    
    log "SUCCESS" "‚úÖ Todas as verifica√ß√µes pr√©-deploy passaram"
}

# Run tests
run_tests() {
    if [[ "$SKIP_TESTS" == true ]]; then
        log "WARN" "‚è≠Ô∏è Pulando testes (--skip-tests especificado)"
        return 0
    fi
    
    log "INFO" "üß™ Executando testes..."
    
    cd "$SCRIPT_DIR/apps/backend"
    
    # Unit tests
    log "DEBUG" "Executando testes unit√°rios..."
    if ! npm run test:unit; then
        log "ERROR" "Testes unit√°rios falharam"
        return 1
    fi
    
    # Integration tests
    log "DEBUG" "Executando testes de integra√ß√£o..."
    if ! npm run test:integration; then
        log "ERROR" "Testes de integra√ß√£o falharam"
        return 1
    fi
    
    # Security scan (se dispon√≠vel)
    if command -v npm audit &> /dev/null; then
        log "DEBUG" "Executando auditoria de seguran√ßa..."
        npm audit --audit-level moderate || log "WARN" "Vulnerabilidades encontradas"
    fi
    
    log "SUCCESS" "‚úÖ Todos os testes passaram"
}

# Backup database
backup_database() {
    if [[ "$SKIP_BACKUP" == true ]]; then
        log "WARN" "‚è≠Ô∏è Pulando backup (--skip-backup especificado)"
        return 0
    fi
    
    log "INFO" "üíæ Criando backup do banco de dados..."
    
    mkdir -p "$BACKUP_DIR"
    
    local backup_file="$BACKUP_DIR/mediapp_${DEPLOY_ENVIRONMENT}_$(date +%Y%m%d_%H%M%S).sql"
    local db_container="mediapp-db-${DEPLOY_ENVIRONMENT}"
    
    # Check if database container exists and is running
    if ! docker ps | grep -q "$db_container"; then
        log "WARN" "Container $db_container n√£o encontrado, pulando backup"
        return 0
    fi
    
    # Create backup
    if docker exec "$db_container" pg_dump -U mediapp mediapp_db > "$backup_file"; then
        log "SUCCESS" "‚úÖ Backup criado: $backup_file"
        
        # Compress backup
        if command -v gzip &> /dev/null; then
            gzip "$backup_file"
            log "DEBUG" "Backup comprimido: ${backup_file}.gz"
        fi
        
        # Clean old backups (keep last 5)
        find "$BACKUP_DIR" -name "mediapp_${DEPLOY_ENVIRONMENT}_*.sql*" -type f | sort -r | tail -n +6 | xargs rm -f
        
    else
        log "ERROR" "Falha ao criar backup"
        return 1
    fi
}

# Build application
build_application() {
    log "INFO" "üèóÔ∏è Construindo aplica√ß√£o..."
    
    cd "$SCRIPT_DIR/apps/backend"
    
    # Install dependencies
    log "DEBUG" "Instalando depend√™ncias..."
    npm ci --only=production
    
    # Generate Prisma client
    log "DEBUG" "Gerando cliente Prisma..."
    npx prisma generate
    
    # Build Docker images
    log "DEBUG" "Construindo imagens Docker..."
    
    local image_tag="${APP_NAME,,}:${VERSION}-${DEPLOY_ENVIRONMENT}"
    
    if [[ "$DRY_RUN" == true ]]; then
        log "INFO" "üîç [DRY-RUN] Construiria imagem: $image_tag"
    else
        if docker build -t "$image_tag" .; then
            log "SUCCESS" "‚úÖ Imagem constru√≠da: $image_tag"
        else
            log "ERROR" "Falha ao construir imagem Docker"
            return 1
        fi
    fi
}

# Deploy using strategy
deploy_application() {
    log "INFO" "üöÄ Iniciando deploy ($DEPLOY_STRATEGY strategy)..."
    
    case "$DEPLOY_STRATEGY" in
        "rolling")
            deploy_rolling
            ;;
        "blue-green")
            deploy_blue_green
            ;;
        "recreate")
            deploy_recreate
            ;;
        *)
            log "ERROR" "Estrat√©gia de deploy desconhecida: $DEPLOY_STRATEGY"
            return 1
            ;;
    esac
}

deploy_rolling() {
    log "DEBUG" "Executando deploy rolling..."
    
    local compose_file="$CONFIG_DIR/docker/docker-compose.${DEPLOY_ENVIRONMENT}.yml"
    local env_file="$CONFIG_DIR/environments/${DEPLOY_ENVIRONMENT}.env"
    
    if [[ "$DRY_RUN" == true ]]; then
        log "INFO" "üîç [DRY-RUN] Executaria: docker-compose -f $compose_file --env-file $env_file up -d"
        return 0
    fi
    
    # Load environment
    set -a
    source "$env_file"
    set +a
    
    # Deploy
    if docker-compose -f "$compose_file" up -d --remove-orphans; then
        log "SUCCESS" "‚úÖ Deploy rolling conclu√≠do"
    else
        log "ERROR" "Falha no deploy rolling"
        return 1
    fi
}

deploy_blue_green() {
    log "DEBUG" "Executando deploy blue-green..."
    
    # Implementation for blue-green deployment
    # This would require more complex logic with two environments
    
    if [[ "$DRY_RUN" == true ]]; then
        log "INFO" "üîç [DRY-RUN] Executaria deploy blue-green"
        return 0
    fi
    
    log "WARN" "Blue-green deployment n√£o implementado ainda"
    log "INFO" "Fallback para rolling deployment"
    deploy_rolling
}

deploy_recreate() {
    log "DEBUG" "Executando deploy recreate..."
    
    local compose_file="$CONFIG_DIR/docker/docker-compose.${DEPLOY_ENVIRONMENT}.yml"
    local env_file="$CONFIG_DIR/environments/${DEPLOY_ENVIRONMENT}.env"
    
    if [[ "$DRY_RUN" == true ]]; then
        log "INFO" "üîç [DRY-RUN] Executaria recreate deployment"
        return 0
    fi
    
    # Load environment
    set -a
    source "$env_file"
    set +a
    
    # Stop and remove
    docker-compose -f "$compose_file" down --remove-orphans || true
    
    # Deploy
    if docker-compose -f "$compose_file" up -d; then
        log "SUCCESS" "‚úÖ Deploy recreate conclu√≠do"
    else
        log "ERROR" "Falha no deploy recreate"
        return 1
    fi
}

# Health checks
health_checks() {
    log "INFO" "üè• Executando health checks..."
    
    local port="${ENV_PORTS[$DEPLOY_ENVIRONMENT]}"
    local max_attempts=30
    local attempt=1
    
    while [[ $attempt -le $max_attempts ]]; do
        if curl -s -f "http://localhost:$port/health" > /dev/null 2>&1; then
            log "SUCCESS" "‚úÖ Aplica√ß√£o respondendo na porta $port"
            
            # Advanced health checks
            local health_response=$(curl -s "http://localhost:$port/health" | jq -r '.status' 2>/dev/null || echo "unknown")
            
            if [[ "$health_response" == "healthy" ]]; then
                log "SUCCESS" "‚úÖ Health check avan√ßado passou"
                return 0
            else
                log "WARN" "Health check retornou: $health_response"
            fi
        fi
        
        log "DEBUG" "Health check tentativa $attempt/$max_attempts..."
        sleep 2
        ((attempt++))
    done
    
    log "ERROR" "Health checks falharam ap√≥s $max_attempts tentativas"
    return 1
}

# Post-deploy tasks
post_deploy() {
    log "INFO" "üîß Executando tarefas p√≥s-deploy..."
    
    # Database migrations
    log "DEBUG" "Executando migra√ß√µes do banco..."
    cd "$SCRIPT_DIR/apps/backend"
    
    if [[ "$DRY_RUN" == true ]]; then
        log "INFO" "üîç [DRY-RUN] Executaria migra√ß√µes do banco"
    else
        npm run db:migrate || log "WARN" "Migra√ß√µes falharam"
    fi
    
    # Warm up cache
    log "DEBUG" "Aquecendo cache..."
    local port="${ENV_PORTS[$DEPLOY_ENVIRONMENT]}"
    
    curl -s "http://localhost:$port/api/medicos" > /dev/null 2>&1 || true
    curl -s "http://localhost:$port/api/pacientes" > /dev/null 2>&1 || true
    
    # Send notifications (if configured)
    send_notifications "success"
    
    log "SUCCESS" "‚úÖ Tarefas p√≥s-deploy conclu√≠das"
}

# Send notifications
send_notifications() {
    local status=$1
    
    if [[ -z "${SLACK_WEBHOOK_URL:-}" ]]; then
        return 0
    fi
    
    local color="#36a64f"  # green
    local emoji="‚úÖ"
    
    if [[ "$status" != "success" ]]; then
        color="#ff0000"  # red
        emoji="‚ùå"
    fi
    
    local message="$emoji Deploy $APP_NAME v$VERSION para $DEPLOY_ENVIRONMENT: $status"
    
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"$message\"}" \
        "$SLACK_WEBHOOK_URL" 2>/dev/null || true
}

# Rollback function
rollback() {
    log "WARN" "üîÑ Iniciando rollback..."
    
    # Implementation for rollback
    # This would restore from backup and previous container version
    
    log "INFO" "Rollback n√£o implementado ainda"
    log "INFO" "Para rollback manual:"
    log "INFO" "1. Restaurar backup do banco"
    log "INFO" "2. Fazer deploy da vers√£o anterior"
}

# Display final status
show_final_status() {
    local deploy_status=$?
    
    echo ""
    log "INFO" "üìä Status Final do Deploy:"
    echo ""
    
    if [[ $deploy_status -eq 0 ]]; then
        echo -e "${GREEN}üéâ DEPLOY CONCLU√çDO COM SUCESSO! üéâ${NC}"
    else
        echo -e "${RED}‚ùå DEPLOY FALHOU! ‚ùå${NC}"
    fi
    
    echo ""
    log "INFO" "Ambiente: $DEPLOY_ENVIRONMENT"
    log "INFO" "Estrat√©gia: $DEPLOY_STRATEGY"
    log "INFO" "Vers√£o: $VERSION"
    log "INFO" "Branch: ${GIT_BRANCH:-unknown}"
    log "INFO" "Commit: ${GIT_COMMIT:-unknown}"
    
    local port="${ENV_PORTS[$DEPLOY_ENVIRONMENT]}"
    echo ""
    log "INFO" "üåê URLs da aplica√ß√£o:"
    log "INFO" "  ‚Ä¢ Principal: http://localhost:$port"
    log "INFO" "  ‚Ä¢ Health: http://localhost:$port/health"
    log "INFO" "  ‚Ä¢ API: http://localhost:$port/api"
    
    echo ""
    log "INFO" "üìÅ Logs dispon√≠veis em: $LOG_DIR"
    
    if [[ $deploy_status -ne 0 ]]; then
        echo ""
        log "ERROR" "Para rollback: $0 --rollback"
    fi
}

# Trap for cleanup
trap 'show_final_status' EXIT

# Main function
main() {
    print_banner
    
    parse_args "$@"
    
    log "INFO" "üöÄ Iniciando deploy $APP_NAME v$VERSION"
    log "INFO" "Ambiente: $DEPLOY_ENVIRONMENT"
    log "INFO" "Estrat√©gia: $DEPLOY_STRATEGY"
    
    if [[ "$DRY_RUN" == true ]]; then
        log "WARN" "üîç MODO DRY-RUN - Nenhuma altera√ß√£o ser√° feita"
    fi
    
    # Execute deployment pipeline
    preflight_checks
    run_tests
    backup_database
    build_application
    deploy_application
    health_checks
    post_deploy
    
    log "SUCCESS" "üéâ Deploy conclu√≠do com sucesso!"
}

# Execute main function
main "$@"