#!/usr/bin/env bash
# üè• MediApp v3.0.0 - Sistema de Monitoramento
# Monitoramento unificado da aplica√ß√£o

set -euo pipefail

# Configura√ß√µes
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly APP_NAME="MediApp"
readonly VERSION="3.0.0"
readonly CONFIG_DIR="$SCRIPT_DIR/config"
readonly LOG_DIR="/tmp/mediapp-monitor"

# Cores para output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

# Configura√ß√£o padr√£o
ENVIRONMENT="development"
CHECK_INTERVAL=30
ALERT_THRESHOLD=3
LOG_RETENTION_DAYS=7

# Logging
log() {
    local level=$1; shift
    local msg="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    mkdir -p "$LOG_DIR"
    
    case $level in
        "INFO")  echo -e "${GREEN}[INFO]${NC}  [$timestamp] $msg" | tee -a "$LOG_DIR/monitor.log" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC}  [$timestamp] $msg" | tee -a "$LOG_DIR/monitor.log" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} [$timestamp] $msg" | tee -a "$LOG_DIR/monitor.log" ;;
        "DEBUG") echo -e "${BLUE}[DEBUG]${NC} [$timestamp] $msg" | tee -a "$LOG_DIR/monitor.log" ;;
        "SUCCESS") echo -e "${PURPLE}[SUCCESS]${NC} [$timestamp] $msg" | tee -a "$LOG_DIR/monitor.log" ;;
    esac
}

# Banner
print_banner() {
    clear
    echo -e "${CYAN}"
    cat << 'EOF'
üìä ========================================================
   __  __          _ _    _                
  |  \/  | ___  __| (_)  / \   _ __  _ __  
  | |\/| |/ _ \/ _` | | / _ \ | '_ \| '_ \ 
  | |  | |  __/ (_| | |/ ___ \| |_) | |_) |
  |_|  |_|\___|\__,_|_/_/   \_\ .__/| .__/ 
                              |_|   |_|    
        Sistema de Monitoramento v3.0.0
üìä ========================================================
EOF
    echo -e "${NC}"
}

# Ajuda
show_help() {
    echo -e "${CYAN}USO:${NC}"
    echo "  $0 [COMMAND] [OPTIONS]"
    echo ""
    echo -e "${CYAN}COMMANDS:${NC}"
    echo "  status           Verificar status dos servi√ßos"
    echo "  health           Health check completo"
    echo "  logs             Visualizar logs"
    echo "  metrics          Coletar m√©tricas"
    echo "  alerts           Verificar alertas"
    echo "  watch            Monitoramento cont√≠nuo"
    echo "  dashboard        Abrir dashboard web"
    echo "  report           Gerar relat√≥rio"
    echo ""
    echo -e "${CYAN}OPTIONS:${NC}"
    echo "  -e, --environment ENV    Ambiente (development|staging|production)"
    echo "  -i, --interval SEC       Intervalo de verifica√ß√£o (padr√£o: 30s)"
    echo "  -t, --threshold NUM      Limite de falhas para alerta (padr√£o: 3)"
    echo "  -v, --verbose           Modo verboso"
    echo "  -h, --help              Mostrar ajuda"
}

# Parse argumentos
parse_args() {
    local command=""
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            status|health|logs|metrics|alerts|watch|dashboard|report)
                command="$1"
                shift
                ;;
            -e|--environment)
                ENVIRONMENT="$2"
                shift 2
                ;;
            -i|--interval)
                CHECK_INTERVAL="$2"
                shift 2
                ;;
            -t|--threshold)
                ALERT_THRESHOLD="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log "ERROR" "Argumento desconhecido: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    export MONITOR_COMMAND="$command"
    export VERBOSE="$verbose"
}

# Carregar configura√ß√£o do ambiente
load_environment_config() {
    local env_file="$CONFIG_DIR/environments/${ENVIRONMENT}.env"
    
    if [[ -f "$env_file" ]]; then
        set -a
        source "$env_file"
        set +a
        log "DEBUG" "Configura√ß√£o carregada: $env_file"
    else
        log "WARN" "Arquivo de configura√ß√£o n√£o encontrado: $env_file"
    fi
}

# Verificar status dos servi√ßos
check_service_status() {
    log "INFO" "üîç Verificando status dos servi√ßos..."
    
    local services_ok=true
    local status_report=""
    
    # PostgreSQL
    local db_status="‚ùå OFFLINE"
    local db_container="mediapp-db-${ENVIRONMENT}"
    
    if docker ps --format "table {{.Names}}" | grep -q "$db_container"; then
        if docker exec "$db_container" pg_isready -U "${DB_USER:-mediapp}" >/dev/null 2>&1; then
            db_status="‚úÖ ONLINE"
        else
            db_status="‚ö†Ô∏è CONTAINER UP, DB NOT READY"
            services_ok=false
        fi
    else
        services_ok=false
    fi
    
    status_report+="üêò PostgreSQL: $db_status\n"
    
    # Backend Application
    local app_status="‚ùå OFFLINE"
    local app_port="${PORT:-3002}"
    
    if curl -s -f "http://localhost:$app_port/health" >/dev/null 2>&1; then
        app_status="‚úÖ ONLINE"
    else
        services_ok=false
    fi
    
    status_report+="üöÄ Backend: $app_status (porta $app_port)\n"
    
    # Redis (se configurado)
    if [[ "${CACHE_ENABLED:-false}" == "true" ]]; then
        local redis_status="‚ùå OFFLINE"
        local redis_container="mediapp-redis-${ENVIRONMENT}"
        
        if docker ps --format "table {{.Names}}" | grep -q "$redis_container"; then
            if docker exec "$redis_container" redis-cli ping 2>/dev/null | grep -q "PONG"; then
                redis_status="‚úÖ ONLINE"
            else
                redis_status="‚ö†Ô∏è CONTAINER UP, REDIS NOT READY"
                services_ok=false
            fi
        else
            services_ok=false
        fi
        
        status_report+="üìä Redis: $redis_status\n"
    fi
    
    # Exibir resultado
    echo -e "\nüìä STATUS DOS SERVI√áOS:"
    echo "=========================="
    echo -e "$status_report"
    
    if [[ "$services_ok" == true ]]; then
        log "SUCCESS" "‚úÖ Todos os servi√ßos est√£o funcionais"
        return 0
    else
        log "ERROR" "‚ùå Alguns servi√ßos apresentam problemas"
        return 1
    fi
}

# Health check avan√ßado
perform_health_check() {
    log "INFO" "üè• Executando health check avan√ßado..."
    
    local health_score=100
    local checks_total=0
    local checks_passed=0
    
    # Health check da aplica√ß√£o
    ((checks_total++))
    local app_port="${PORT:-3002}"
    local health_response
    
    if health_response=$(curl -s "http://localhost:$app_port/health" 2>/dev/null); then
        ((checks_passed++))
        log "DEBUG" "‚úÖ Application health check OK"
        
        # Verificar detalhes do health check
        if command -v jq >/dev/null 2>&1; then
            local db_status=$(echo "$health_response" | jq -r '.database // "unknown"' 2>/dev/null)
            local uptime=$(echo "$health_response" | jq -r '.uptime // "unknown"' 2>/dev/null)
            
            log "DEBUG" "Database: $db_status, Uptime: $uptime"
        fi
    else
        log "ERROR" "‚ùå Application health check failed"
        health_score=$((health_score - 30))
    fi
    
    # Verificar endpoints cr√≠ticos
    local critical_endpoints=("/api/medicos" "/api/pacientes" "/api/statistics/dashboard")
    
    for endpoint in "${critical_endpoints[@]}"; do
        ((checks_total++))
        if curl -s -f "http://localhost:$app_port$endpoint" >/dev/null 2>&1; then
            ((checks_passed++))
            log "DEBUG" "‚úÖ Endpoint $endpoint OK"
        else
            log "WARN" "‚ö†Ô∏è Endpoint $endpoint failed"
            health_score=$((health_score - 10))
        fi
    done
    
    # Verificar conectividade do banco
    ((checks_total++))
    local db_container="mediapp-db-${ENVIRONMENT}"
    
    if docker exec "$db_container" psql -U "${DB_USER:-mediapp}" -d "${DB_NAME:-mediapp_dev}" -c "SELECT 1;" >/dev/null 2>&1; then
        ((checks_passed++))
        log "DEBUG" "‚úÖ Database connectivity OK"
    else
        log "ERROR" "‚ùå Database connectivity failed"
        health_score=$((health_score - 25))
    fi
    
    # Verificar espa√ßo em disco
    ((checks_total++))
    local disk_usage
    disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    
    if [[ $disk_usage -lt 80 ]]; then
        ((checks_passed++))
        log "DEBUG" "‚úÖ Disk usage OK ($disk_usage%)"
    else
        log "WARN" "‚ö†Ô∏è High disk usage: $disk_usage%"
        health_score=$((health_score - 15))
    fi
    
    # Verificar mem√≥ria
    ((checks_total++))
    local mem_usage
    mem_usage=$(free | awk 'NR==2{printf "%.0f", $3*100/($3+$4)}')
    
    if [[ $mem_usage -lt 85 ]]; then
        ((checks_passed++))
        log "DEBUG" "‚úÖ Memory usage OK ($mem_usage%)"
    else
        log "WARN" "‚ö†Ô∏è High memory usage: $mem_usage%"
        health_score=$((health_score - 10))
    fi
    
    # Resultado final
    echo ""
    log "INFO" "üìä HEALTH CHECK SUMMARY:"
    log "INFO" "Checks passed: $checks_passed/$checks_total"
    log "INFO" "Health score: $health_score/100"
    
    if [[ $health_score -ge 90 ]]; then
        log "SUCCESS" "‚úÖ Sistema em excelente estado"
        return 0
    elif [[ $health_score -ge 70 ]]; then
        log "WARN" "‚ö†Ô∏è Sistema funcional com algumas quest√µes"
        return 1
    else
        log "ERROR" "‚ùå Sistema com problemas cr√≠ticos"
        return 2
    fi
}

# Coletar m√©tricas
collect_metrics() {
    log "INFO" "üìä Coletando m√©tricas do sistema..."
    
    local metrics_file="$LOG_DIR/metrics-$(date +%Y%m%d-%H%M%S).json"
    local app_port="${PORT:-3002}"
    
    # Coletar m√©tricas da aplica√ß√£o
    local app_metrics=""
    if app_metrics=$(curl -s "http://localhost:$app_port/api/statistics/dashboard" 2>/dev/null); then
        log "DEBUG" "‚úÖ M√©tricas da aplica√ß√£o coletadas"
    else
        log "WARN" "‚ö†Ô∏è Falha ao coletar m√©tricas da aplica√ß√£o"
        app_metrics='{"error": "Failed to collect app metrics"}'
    fi
    
    # M√©tricas do sistema
    local system_metrics
    system_metrics=$(cat << EOF
{
  "timestamp": "$(date -Iseconds)",
  "environment": "$ENVIRONMENT",
  "system": {
    "cpu_usage": $(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}'),
    "memory_usage": $(free | awk 'NR==2{printf "%.1f", $3*100/($3+$4)}'),
    "disk_usage": $(df / | awk 'NR==2 {print $5}' | sed 's/%//'),
    "load_average": "$(uptime | awk -F'load average:' '{print $2}')",
    "uptime": "$(uptime -p)"
  },
  "docker": {
    "containers_running": $(docker ps -q | wc -l),
    "images_count": $(docker images -q | wc -l)
  },
  "application": $app_metrics
}
EOF
)
    
    # Salvar m√©tricas
    echo "$system_metrics" > "$metrics_file"
    
    # Exibir resumo
    echo ""
    log "INFO" "üìä M√âTRICAS COLETADAS:"
    
    if command -v jq >/dev/null 2>&1; then
        echo "$system_metrics" | jq -r '
            "CPU: " + (.system.cpu_usage | tostring) + "%",
            "Memory: " + (.system.memory_usage | tostring) + "%", 
            "Disk: " + (.system.disk_usage | tostring) + "%",
            "Load: " + .system.load_average,
            "Containers: " + (.docker.containers_running | tostring)
        '
    else
        log "DEBUG" "M√©tricas salvas em: $metrics_file"
    fi
    
    log "SUCCESS" "‚úÖ M√©tricas coletadas em: $metrics_file"
}

# Visualizar logs
view_logs() {
    log "INFO" "üìã Visualizando logs do sistema..."
    
    local log_type="${1:-all}"
    local lines="${2:-50}"
    
    case $log_type in
        "app"|"application")
            log "INFO" "Logs da aplica√ß√£o (√∫ltimas $lines linhas):"
            tail -n "$lines" "$LOG_DIR"/../mediapp-logs/app.log 2>/dev/null || log "WARN" "Log da aplica√ß√£o n√£o encontrado"
            ;;
        "db"|"database")
            log "INFO" "Logs do PostgreSQL:"
            docker logs "mediapp-db-${ENVIRONMENT}" --tail "$lines" 2>/dev/null || log "WARN" "Container PostgreSQL n√£o encontrado"
            ;;
        "monitor")
            log "INFO" "Logs do monitor (√∫ltimas $lines linhas):"
            tail -n "$lines" "$LOG_DIR/monitor.log" 2>/dev/null || log "WARN" "Log do monitor n√£o encontrado"
            ;;
        "all"|*)
            log "INFO" "Todos os logs dispon√≠veis:"
            echo ""
            echo "üìã APPLICATION LOGS:"
            tail -n 10 "$LOG_DIR"/../mediapp-logs/app.log 2>/dev/null || echo "  N√£o dispon√≠vel"
            echo ""
            echo "üìã DATABASE LOGS:"
            docker logs "mediapp-db-${ENVIRONMENT}" --tail 5 2>/dev/null || echo "  Container n√£o encontrado"
            echo ""
            echo "üìã MONITOR LOGS:"
            tail -n 10 "$LOG_DIR/monitor.log" 2>/dev/null || echo "  N√£o dispon√≠vel"
            ;;
    esac
}

# Monitoramento cont√≠nuo
continuous_monitoring() {
    log "INFO" "üëÄ Iniciando monitoramento cont√≠nuo (intervalo: ${CHECK_INTERVAL}s)..."
    log "INFO" "Pressione Ctrl+C para parar"
    
    local consecutive_failures=0
    local start_time=$(date +%s)
    
    while true; do
        echo ""
        echo "======================================"
        echo "üïê $(date '+%Y-%m-%d %H:%M:%S')"
        echo "======================================"
        
        if check_service_status >/dev/null 2>&1; then
            consecutive_failures=0
            log "SUCCESS" "‚úÖ Todos os servi√ßos OK"
        else
            ((consecutive_failures++))
            log "ERROR" "‚ùå Falha detectada ($consecutive_failures/$ALERT_THRESHOLD)"
            
            if [[ $consecutive_failures -ge $ALERT_THRESHOLD ]]; then
                send_alert "Servi√ßos com falha por $consecutive_failures verifica√ß√µes consecutivas"
                consecutive_failures=0  # Reset para evitar spam
            fi
        fi
        
        # Estat√≠sticas de uptime
        local current_time=$(date +%s)
        local uptime_seconds=$((current_time - start_time))
        local uptime_minutes=$((uptime_seconds / 60))
        
        log "INFO" "Monitor rodando h√° ${uptime_minutes} minutos"
        
        sleep "$CHECK_INTERVAL"
    done
}

# Enviar alerta
send_alert() {
    local message="$1"
    
    log "ERROR" "üö® ALERTA: $message"
    
    # Slack webhook (se configurado)
    if [[ -n "${SLACK_WEBHOOK_URL:-}" ]]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"üö® MediApp Alert: $message\"}" \
            "$SLACK_WEBHOOK_URL" >/dev/null 2>&1 || true
    fi
    
    # Email (se configurado)
    if command -v mail >/dev/null 2>&1 && [[ -n "${ALERT_EMAIL:-}" ]]; then
        echo "Alert from MediApp: $message" | mail -s "üö® MediApp Alert" "$ALERT_EMAIL" || true
    fi
    
    # Log local
    echo "$(date -Iseconds) ALERT: $message" >> "$LOG_DIR/alerts.log"
}

# Gerar relat√≥rio
generate_report() {
    log "INFO" "üìä Gerando relat√≥rio do sistema..."
    
    local report_file="$LOG_DIR/report-$(date +%Y%m%d-%H%M%S).md"
    
    cat > "$report_file" << EOF
# üìä MediApp System Report

**Generated:** $(date '+%Y-%m-%d %H:%M:%S')  
**Environment:** $ENVIRONMENT  
**Version:** $VERSION

## üîç Service Status

EOF
    
    # Adicionar status dos servi√ßos
    if check_service_status >> "$report_file" 2>&1; then
        echo "‚úÖ **Overall Status:** HEALTHY" >> "$report_file"
    else
        echo "‚ùå **Overall Status:** ISSUES DETECTED" >> "$report_file"
    fi
    
    echo "" >> "$report_file"
    echo "## üìä System Metrics" >> "$report_file"
    echo "" >> "$report_file"
    
    # Adicionar m√©tricas
    cat << EOF >> "$report_file"
- **CPU Usage:** $(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')%
- **Memory Usage:** $(free | awk 'NR==2{printf "%.1f", $3*100/($3+$4)}')%  
- **Disk Usage:** $(df / | awk 'NR==2 {print $5}')
- **Load Average:** $(uptime | awk -F'load average:' '{print $2}')
- **Uptime:** $(uptime -p)

## üê≥ Docker Status

- **Running Containers:** $(docker ps -q | wc -l)
- **Total Images:** $(docker images -q | wc -l)

EOF
    
    log "SUCCESS" "‚úÖ Relat√≥rio gerado: $report_file"
    
    # Abrir relat√≥rio se poss√≠vel
    if command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$report_file" 2>/dev/null || true
    fi
}

# Fun√ß√£o principal
main() {
    if [[ -z "${MONITOR_COMMAND:-}" ]]; then
        print_banner
        show_help
        exit 0
    fi
    
    print_banner
    log "INFO" "üöÄ MediApp Monitor v$VERSION"
    log "INFO" "Environment: $ENVIRONMENT"
    
    load_environment_config
    
    case "$MONITOR_COMMAND" in
        "status")
            check_service_status
            ;;
        "health")
            perform_health_check
            ;;
        "logs")
            view_logs "$@"
            ;;
        "metrics")
            collect_metrics
            ;;
        "watch")
            continuous_monitoring
            ;;
        "report")
            generate_report
            ;;
        "dashboard")
            log "INFO" "üåê Abrindo dashboard..."
            local app_port="${PORT:-3002}"
            
            if command -v xdg-open >/dev/null 2>&1; then
                xdg-open "http://localhost:$app_port" 2>/dev/null || true
            else
                log "INFO" "Dashboard dispon√≠vel em: http://localhost:$app_port"
            fi
            ;;
        *)
            log "ERROR" "Comando desconhecido: $MONITOR_COMMAND"
            show_help
            exit 1
            ;;
    esac
}

# Trap para cleanup
trap 'log "INFO" "Monitor interrompido"; exit 0' INT TERM

# Executar fun√ß√£o principal
parse_args "$@"
main "$@"